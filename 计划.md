git add添加到管理  红变绿
commit到本地 绿变白
修改 白变蓝
push到远程

![img.png](img.png)
# 登录拦截及权限校验
* 前端路由不展示的界面后端还有必要做权限校验吗?
* 客户端可以被绕过：前端路由的限制可以很容易被绕过。用户可以通过**直接访问 URL** 或使用工具（如 Postman）绕过前端界面，从而尝试直接请求受保护的资源或接口。如果后端没有做权限校验，恶意用户可以未授权地访问这些资源。
* 保护后端资源：即使前端不展示某些界面，后端资源（例如 API 接口、数据库记录等）仍然需要保护，**以防止未授权访问或数据泄露**。

* 登录拦截器设置拦截路径，拦截需要登陆的路径，2种情况
  * 1：不需要登陆，放行
  * 2：需要登陆，登录后放行
例：未登录用户放行后，要收藏某篇文章，此时路径就是需要登陆才可以访问的
* AOP切面+注解检查身份（使用在类和方法上，核验身份）
  * 如果是放行的未登录用户，则无权进行某些操作，需要登陆
  * 如果是放行的已登录用户，检查身份来决定能否进行某些操作


类名和标签名都有字数限制 10
文章回收箱，存放删除的文章
管理员审核开关，可以开启文章审核或者关闭审核
苍穹外卖P31 自动字段填充用户名，减少冗余代码
苍穹外卖P93  spring cache   Spring EL语法->  #开头：#user.id
![img_1.png](img_1.png)

# 需求分析
* 登陆注册
* 用户
  * 查看、发布、点赞、收藏、评论文章
  * 删除评论、文章
* 文章必须要有类别，可以没标签，类别和标签只能由管理员创建
* 类别和文章是一对多，类别和标签是一对多，标签属于类别
  * 一个文章只能有一个类别，但可以有多个标签
  * 一个类别可以有多个文章
  * 一个类别可以有多个标签
* 管理员
  * 添加、禁用用户
  * 删除、修改、审核文章，文章审核后方可展示
  * 创建、删除、修改标签
  * 创建、删除、修改分类
  * PV、UV可视化统计

* 签到等级功能 BitMap
* ES搜索 增量同步
* 查看留言私信功能
* 关注推送
* Feed流大数据推送
* 文章定时发布
* AI生成文章摘要summary
* 公告功能
* 用户查看收藏

# 系统设计
## 表设计[最初，不是最新的]
### user表：
* 用户ID userId int 
* 头像 avatarUrl   varchar(255)
* 性别  sex  int    (0女 1男  2未知)
* 简介  profiles   varchar(1024)
* 用户名  userName varchar(255)
* 密码 password  varchar(255)
* 邮箱 mail varchar(100)
* 角色  role  int （0普通用户，1管理员）
* 发布createTime
* 修改时间updateTime
* 用户状态 status （0禁用 1正常）
* 逻辑删除isDelete

### passage表：
* 主键passageId  int
* 作者id authorId  int
* 标题title varchar(255)
* 内容 content text
* 预览图  thumbnail
* 内容摘要 summary  varchar(512)
* 浏览量  viewCount  int
* 点赞数量thumbs  int
* 收藏数量collects int
* 发布createTime
* 修改时间updateTime 
* 状态  status  （0 草稿  ，1 待审核  ，2 已发布）
* 逻辑删除isDelete        

### passage_tag表：多对多，可以根据标签查多个文章
* passageId  主键
* tags  varchar(255)  comment '多个标签组成的json字符串'

### tag表：
* 主键 tagId 
* 创建标签的用户Id   createUserId
* tagName  标签名 
* 逻辑删除isDelete
* 发布时间createTime
* 修改时间updateTime 

### comment表：
* 主键  commentId
* 评论的文章id  passageId
* 评论的内容 content
* 评论的用户id   commentUserId
* 向哪个评论id回复  toCommentId
* 向哪个用户的评论回复  toCommentUserId   redis消息推送，通知用户（可扩展）
* 逻辑删除  isDelete  (0未删除   1已删除)


# 功能设计
不管是后端返回给前端的数据还是全局异常处理器返回给前端的异常统一都是BaseResponse类型，这是返回基类
异常处理  ErrorCode  自定义异常BusinessException ->全局异常处理器GlobalExceptionHandler(全局异常处理器要返回给前端，返回BaseResponse类型)
返回前端  ResultUtils包 最终给前端返回的也是BaseResponse类型